#!/usr/bin/env python3
"""
Post-production video processing tool.

This script automatically activates its own virtual environment before running,
ensuring all dependencies are isolated and available.
"""
import os
import sys
from pathlib import Path

# Get the directory where this script lives (resolve symlinks)
script_path = Path(__file__).resolve()
script_dir = script_path.parent
venv_dir = script_dir / "post-venv"

# Re-exec with the virtualenv's Python interpreter when available
if venv_dir.exists():
    if sys.platform == "win32":
        venv_python = venv_dir / "Scripts" / "python.exe"
    else:
        venv_python = venv_dir / "bin" / "python"

    try:
        current_python = Path(sys.executable).resolve()
    except FileNotFoundError:
        current_python = Path(sys.executable)

    if venv_python.exists() and current_python != venv_python.resolve():
        os.execv(str(venv_python), [str(venv_python), str(script_path), *sys.argv[1:]])

# At this point we're running inside the virtualenv interpreter (or it was missing).
# Ensure the virtualenv site-packages is on sys.path when present.
if venv_dir.exists() and not hasattr(sys, "real_prefix") and not (
    hasattr(sys, "base_prefix") and sys.base_prefix != sys.prefix
):
    if sys.platform == "win32":
        site_packages = venv_dir / "Lib" / "site-packages"
    else:
        python_version = f"python{sys.version_info.major}.{sys.version_info.minor}"
        site_packages = venv_dir / "lib" / python_version / "site-packages"

    if site_packages.exists():
        sys.path.insert(0, str(site_packages))
        os.environ["VIRTUAL_ENV"] = str(venv_dir)
        if "PYTHONHOME" in os.environ:
            del os.environ["PYTHONHOME"]

import importlib.util

def main():
    # Get module directory
    modules_dir = script_dir / "modules"
    
    # Parse command line arguments
    if len(sys.argv) < 2:
        print("Usage: post -<command> [args...]")
        print("\nAvailable commands:")
        print("  -process     Run full pipeline: tighten → transcribe → essay → captions")
        print("  -cuttakes    Extract multiple takes from video based on timestamps")
        print("  -tighten     Remove silence from video")
        print("  -convert     Convert rough cut to all-intra H.264 for fast tightening")
        print("  -compress    Compress video with VideoToolbox and crop to 4:3")
        print("  -denoise     Remove background noise from audio using AI models (DeepFilterNet/Facebook)")
        print("  -separate-audio Extract the audio track from a video file")
        print("  -transcribe  Generate word-level timestamps")
        print("  -essay       Generate essay/transcript from timestamps")
        print("  -captions    Add captions to video")
        print("  -endcard     Add endcard to video")
        print("  -stitch      Stitch multiple videos together")
        sys.exit(1)
    
    # Get the command (first argument, without the leading -)
    command_arg = sys.argv[1]
    if not command_arg.startswith("-"):
        print(f"Error: Command must start with '-' (got: {command_arg})")
        sys.exit(1)
    
    command = command_arg[1:]  # Remove the leading -
    remaining_args = sys.argv[2:]  # Arguments to pass to the module
    
    # Build the path to the module file
    module_path = modules_dir / f"{command}.py"
    
    if not module_path.exists():
        print(f"Error: Unknown command '{command}'")
        print(f"Expected module file: {module_path}")
        sys.exit(1)
    
    # Add modules directory to sys.path so modules can import from each other
    if str(modules_dir) not in sys.path:
        sys.path.insert(0, str(modules_dir))
    
    # Dynamically import the module
    spec = importlib.util.spec_from_file_location(command, module_path)
    if spec is None or spec.loader is None:
        print(f"Error: Could not load module from {module_path}")
        sys.exit(1)
    
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    
    # Check if the module has a run() function
    if not hasattr(module, "run"):
        print(f"Error: Module '{command}' does not have a run() function")
        sys.exit(1)
    
    # Call the module's run() function with remaining arguments
    module.run(remaining_args)

if __name__ == "__main__":
    main()

